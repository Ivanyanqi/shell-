tr是Unix命令行专家工具箱中一件简约却不失精美的工具。
它经常用来编写优美的单行命 令，作用不容小视。
tr可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩。 
它可以将一组字符变成另一组字符，因而通常也被称为转换(translate)命令。
在这则攻略中，我们会看到如何使用tr进行基本的集合转换

tr只能通过stdin(标准输入)，而无法通过命令行参数来接受输入
它的调用格式如下
tr [option] set1 set2
将来自stdin的输入字符从set1映射到set2，然后将输出写入stdout(标准输出)。
set1 和set2是字符类或字符集。如果两个字符集的长度不相等，那么set2会不断重复其最后一个字符，直到长度与set1相同。
如果set2的长度大于set1，那么在set2中超出set1长度的那部分 字符则全部被忽略
将输入字符由大写转换成小写，可以使用下面的命令
echo "HELLO WHO IS THIS" | tr "A-Z" "a-z" (引号也可以不加)
'A-Z' 和 'a-z'都是集合
'ABD-}'、'aA.,'、'a-ce-x'以及'a-c0-9'等均是合法的集合。
定义集合也很简单，不需要书写一长串连续的字符序列，只需要使用“起始字符-终止字符”这种格式就行了
如果“起始字符-终止字符”不是一个连续的字符序列， 那么它就会被视为包含了3个元素的集合，
也就是:起始字符，-，终止字符。你可以使用像'\t'、 '\n'这种特殊字符，也可以使用其他ASCII字符

通过在tr中使用集合的概念，我们可以轻松地将字符从一个集合映射到另一个集合中
echo 12345 | tr '0-9' '9876543210' # 加密
echo 87654 | tr '9876543210' '0-9' # 解密

ROT13是一个著名的加密算法。在ROT13算法中，文本加密和解密都使用同一个函数
ROT13 按照字母表排列顺序执行13个字母的转换。用tr进行ROT13加密
echo "tr came, tr saw, tr conquered." | tr 'a-zA-Z' 'n-za-mN-ZA-M'

echo "ge pnzr, ge fnj, ge pbadhrerq." | tr 'n-za-mN-ZA-M' 'a-zA-Z'

tr 还可以将制表符转换为空格
tr '\t' ' ' < file.txt
cat file.txt | tr '\t' ' '
两种方式获取标准输入

补充内容
用tr删除字符
cat file.txt | tr -d set1
将stdin中的数字删除并打印出来
echo "Hello 123 world 456" | tr -d "0-9"

字符集补集
我们可以利用选项-c来使用set1的补集。下面的命令中，set2是可选的
tr -c [set1] [set2]
set1的补集意味着这个集合中包含set1中没有的所有字符
最典型的用法是从输入文本中将不在补集中的所有字符全部删除

echo hello 1 char 2 next 4 | tr -d -c '0-9 \n'
在这里，补集中包含了除数字、空格字符和换行符之外的所有字符。
因为指定了-d，所以这 些字符全部都被删除
用tr压缩字符
tr命令在很多文本处理环境中大有用武之地。
多数情况下，连续的重复字符应该压缩成单个字符。
经常需要从事的一项任务就是压缩空白字符
-s 选项可以压缩输入中重复的字符
echo "GNU is       not     UNIX. Recursive   right ?" | tr -s ' '
tr -s '[set]'

用tr将文件中的数字列表相加cat 
cat sum.txt | echo $[$(tr '\n' '+') 0]
tr用来将'\n'替换成'+',因此我们得到了字符串"1+2+3+...5+" 
但是在字符串的尾部多了一个操作符+。为了抵消这个多出来的操作符，我们再追加一个0
$[ operation ] 执行算术运算，因此得到下面的字符串

字符类
tr可以像使用集合一样使用各种不同的字符类
 alnum:字母和数字。
 alpha:字母。
 cntrl:控制(非打印)字符。 
 digit:数字。
 graph:图形字符。
 lower:小写字母。
 print:可打印字符。
 punct:标点符号。
 space:空白字符。
 upper:大写字母。
 xdigit:十六进制字符

tr [:class:] [:class:]

